# -*- coding: utf-8 -*-
"""quadratic_problem.ipynb

Automatically generated by Colaboratory.
"""

import numpy as np
import cvxpy as cp

print("1. Use cvxpy library")

x1 = cp.Variable()
x2 = cp.Variable()

constraint = [ x1 <= 1,
              x2 <= 1,
              -x1 <= 1,
              -x2 <= 1]

obj = cp.Minimize(x1**2 + 2*x2**2 + x1*x2 + 5*x1 + 3*x2)

prob = cp.Problem(obj, constraint)
print("=="*20) # 만약 infeasible이거나, 문제가 있을 경우 여기서 알 수 있음.
if prob.status=='optimal':
    print(f"status: {prob.status}") 
    print("optimal value", prob.value)
    print("optimal var", x1.value, x2.value)
else:
    print(f"Wrong status: {prob.status}")
print("=="*20)
print("\n\n")

print("2. Use crude method, increasing dual variable little by little every time")

#quadratic problem에 필요한 행렬 구현
Q = np.array([[2, 1],[1, 4]]).astype('float64')
c = np.array([[5], [3]]).astype('float64').reshape(2, 1)
A = np.array([[1, 0], [-1, 0], [0, 1], [0, -1]]).reshape(4, 2).astype('float64')
b = np.array([[1], [1], [1], [1]]).astype('float64')

# objective function
def min(y, Q, c):
#  return 0.5*((y.T).dot(Q)).dot(y) + (c.T).dot(y)
  return y1**2 + 2*y2**2 + y1*y2 + 5*y1 + 3*y2

y1 = -1
y2 = -1
y = np.array([y1, y2]).reshape(2, 1).astype('float32')

# 초기값 저장
base = min(y, Q, c)
result = base
save_y1 = y1
save_y2 = y2

# y1과 y2를 -1부터 0.001씩 증가시키면서 최솟값 탐색
for i in range(0,2001):
  y1 += 0.001
  y2 = -1
  for j in range(0, 2001):
    y2 += 0.001
    update = min(y, Q, c)
    if(base > update):
      result = update
      base = update
      save_y1 = y1
      save_y2 = y2
 
 # 결과 출력
print("=="*20)
print("result:",round(result,3))
print("y1 =", round(save_y1,3))
print("y2 =" , round(save_y2,3))
print("=="*20)
